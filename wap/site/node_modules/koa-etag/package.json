{
  "name": "koa-etag",
  "description": "ETag support for koa",
  "repository": {
    "type": "git",
    "url": "git://github.com/koajs/etag"
  },
  "version": "1.3.1",
  "keywords": [
    "koa",
    "middleware",
    "cache",
    "caching",
    "etag",
    "file",
    "static",
    "sendfile"
  ],
  "files": [
    "index.js"
  ],
  "devDependencies": {
    "koa": "*",
    "should": "3",
    "mocha": "1",
    "supertest": "0",
    "koa-static": "1"
  },
  "license": "MIT",
  "dependencies": {
    "buffer-crc32": "~0.2.1"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "\n# koa-etag\n\n ETag support for Koa responses.\n\n## Installation\n\n```js\n$ npm install koa-etag\n```\n\n## Example\n\n```js\nvar conditional = require('koa-conditional-get');\nvar etag = require('koa-etag');\nvar koa = require('koa');\nvar app = koa();\n\n// etag works together with conditional-get\napp.use(conditional());\napp.use(etag());\n\napp.use(function(next){\n  return function *(){\n    yield next;\n    this.body = 'Hello World';\n  }\n})\n\napp.listen(3000);\n\nconsole.log('listening on port 3000');\n```\n\n## Options\n\n### hash\n\nBy default, `etag` uses `crc32` to calculate bodies.\nIf you want to use a custom function,\nset `options.hash`.\nCustom etag calculation functions should accept both strings and buffers.\n\nFor example, to use hex-encoded `sha256` sums:\n\n```js\nvar crypto = require('crypto');\n\napp.use(etag({\n  hash: function (body) {\n    return crypto.createHash('sha256')\n      .update(body)\n      .digest('hex');\n  }\n}));\n```\n\n## License\n\n  MIT\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/koajs/etag/issues"
  },
  "homepage": "https://github.com/koajs/etag",
  "_id": "koa-etag@1.3.1",
  "_shasum": "b515cb45c198beade9d4f3a2e2770cde3e22fb24",
  "_from": "koa-etag@^1.3.0",
  "_resolved": "https://registry.npmjs.org/koa-etag/-/koa-etag-1.3.1.tgz"
}
